require 'fileutils'

IGNORED_HEADERS = [
  'headers/SDL_main.h'
]

# List the names of any functions for which c-lambdas should not
# be automatically generated here.
IGNORED_FUNCTIONS = [
  'SDL_AndroidGetInternalStoragePath',
  'SDL_AndroidGetExternalStorageState',
  'SDL_AndroidGetExternalStoragePath',
  'SDL_Direct3D9GetAdapterIndex',
  'SDL_iPhoneSetEventPump'
]

TYPES = {
    
    'void' => {
      :gambit => 'void'
    },

    'int' => {
      :gambit => 'int'
    },

    'double' => {
      :gambit => 'double'
    },

    'float' => {
      :gambit => 'float'
    },

    'char*' => {
      :gambit => 'char-string'
    },

    'const char*' => {
      :gambit => 'char-string'
    },

    'size_t' => {
      :gambit => 'size_t'
    },

    'long' => {
      :gambit => 'long'
    },

    'unsigned int' => {
      :gambit => 'unsigned-int'
    },

    #
    #

    'SDL_bool' => {
      :gambit => 'SDL_bool',
      :declare_as => 'int'
    },

    'Uint64' => {
      :gambit => 'Uint64',
      :declare_as => 'unsigned-int64'
    },

    'Uint32' => {
      :gambit => 'Uint32',
      :declare_as => 'unsigned-int32'
    },

    'Uint16' => {
      :gambit => 'Uint16',
      :declare_as => 'unsigned-int16'
    },

    'Uint8' => {
      :gambit => 'Uint8',
      :declare_as => 'unsigned-int8'
    },

    #
    # Pointers

    'SDL_RendererInfo*' => {
      :gambit => 'sdl::renderer-info-ptr',
      :declare_as => '(pointer "SDL_RendererInfo")'
    },
    
    'SDL_Window*' => {
      :gambit => 'sdl::window-ptr',
      :declare_as => '(pointer "SDL_Window")'
    },
    
    'SDL_Renderer*' => {
      :gambit => 'sdl::renderer-ptr',
      :declare_as => '(pointer "SDL_Renderer")'
    },
    
    'SDL_Surface*' => {
      :gambit => 'sdl::surface-ptr',
      :declare_as => '(pointer "SDL_Surface")'
    },
    
    'SDL_Texture*' => {
      :gambit => 'sdl::texture-ptr',
      :declare_as => '(pointer "SDL_Texture")'
    },

    'SDL_Cursor*' => {
      :gambit => 'sdl::cursor-ptr',
      :declare_as => '(pointer "SDL_Cursor")'
    },

    'TTF_Font*' => {
      :gambit => 'sdl::ttf-font-ptr',
      :declare_as => '(pointer "TTF_Font")'
    },

    'SDL_Thread*' => {
      :gambit => 'sdl::thread-ptr',
      :declare_as => '(pointer "SDL_Thread")'
    },

    #
    # Unsupported
}

#
#

$skipped_defs   = [] # deifinitions that were skipped outright
$unknown_types  = {}
$skipped_fns    = []

$functions = File.open(File.dirname(__FILE__) + '/../src/lib/sdl2/functions.scm', 'w')
$functions.puts "; This file is automatically generated"
$functions.puts "; (see binding-generator/gen.rb)"
$functions.puts ""

#
#

class FileLines
  def initialize(src)
    @lines = src.split("\n")
    @ix = 0
  end

  def next_line
    if @ix == @lines.length
      nil
    else
      line = @lines[@ix]
      @ix += 1
      line
    end
  end
end

def gambit_type(c_type, direction)
  entry = TYPES[c_type]
  if !entry
    $unknown_types[c_type] ||= {}
    $unknown_types[c_type][direction] = true
    nil
  else
    entry[:gambit]
  end
end

def generate_types
  File.open(File.dirname(__FILE__) + '/../src/lib/sdl2/types.scm', 'w') do |f|
    TYPES.each do |k,v|
      if v[:declare_as]
        f.puts "(c-define-type"
        f.puts "    #{v[:gambit]}"
        f.puts "    #{v[:declare_as]})"
        f.puts ""
      end
    end
  end
end

def process(file)
  lines = FileLines.new(File.read(file))
  while (line = lines.next_line)
    if line =~ /SDLCALL/
      fndef = line
      while line !~ /\)\s*;/
        fndef += (line = lines.next_line)
      end

      # there is no science behind this; it's completely ad-hoc based
      # on observations of the SDL source.
      fndef = fndef.gsub('SDLCALL', '')
                   .gsub(/^\s*extern DECLSPEC /, '')
                   .gsub(/\s+\*\s+/, '*')             # "  *  " => "*"
                   .gsub(/\*([^\*])/, '* \\1')        # "*foo"  => "* foo"
                   .gsub(/\s+\*/, '*')                # " *"    => "*"
                   .gsub(/\s+\(/, '(')                # "  ("   => "("
                   .gsub(/\s+/, ' ')                  # "   "   => " "
                   .strip

      next if fndef =~ /typedef/

      if fndef =~ /^(((const|unsigned) )?([^\s]+)) (\w+)\(([^\)]*)\);$/
        return_type, name, args = $1, $5, $6

        next if IGNORED_FUNCTIONS.include?(name)

        return_type = gambit_type(return_type, :return)

        arg_types = args.split(',').map(&:strip).map { |a| a.gsub(/ \w+$/, '').gsub(/^const /, '') }
        arg_types = arg_types.map { |at| gambit_type(at, :arg) }

        if arg_types.length == 1 && arg_types[0] == 'void'
          arg_types = []
        end

        gambit_name = name.gsub(/^SDL_/, '')
                          .gsub('RGBSurface', 'RGB_Surface')
                          .gsub(/_/, '-')
                          .gsub(/([^A-Z])([A-Z])/, '\\1-\\2')
                          .gsub(/-+/, '-')
                          .downcase

        gambit_name = 'sdl::' + gambit_name

        if return_type && arg_types.all?
          $functions.puts "(define #{gambit_name}"
          $functions.puts "    (c-lambda (#{arg_types.join(' ')}) #{return_type}"
          $functions.puts "        \"#{name}\"))"
          $functions.puts ""
        else
          $skipped_fns << fndef
        end
      
      else
        $skipped_defs << fndef
      end
    end
  end
end

generate_types
Dir['headers/*.h'].each do |s|
  next if IGNORED_HEADERS.include?(s)
  process(s)
end

puts "Skipped entirely, because I'm too simple to parse them:"
$skipped_defs.each { |d| puts "    #{d}" }
puts

puts "Skipped because parameter types are unsupported:"
$skipped_fns.each { |d| puts "    #{d}" }
puts

if $unknown_types.size > 0
  puts "Uknown types:"
  $unknown_types.each do |type,dirs|
    puts "    #{type} (#{dirs.keys.sort.map(&:to_s).join(',')})"
  end
  puts
end